
import { Image, Notes } from 'mdx-deck'
import { Invert } from 'mdx-deck/layouts'
import {CodeSurfer } from "mdx-deck-code-surfer"
import nightOwl from "prism-react-renderer/themes/nightOwl"

export { default as theme } from './theme'

import  PriceTicker  from 'components/PriceTicker/PriceTicker'
import  PriceTickerCompound  from 'components/PriceTicker/PriceTickerCompound'
import  PriceTickerWithDarkTheme  from 'components/PriceTicker/PriceTickerThemeToggle'
import  Tooltip  from 'components/Tooltip/Tooltip'

# React Component Patterns

  
### Sam Lindstrom
---

# Some background

<Notes>
  Help us to combat:
  - ill-defined project requirements, constant design changes, poorly documented code
</Notes>

---
<CodeSurfer 
  code={require("raw-loader!./snippets/first.snippet")}
  theme={nightOwl}
/>
---

# React Component API
- render
- state
- props
- context
- lifecycle events

---
# Stateful Component

---
<CodeSurfer 
  code={require("raw-loader!./snippets/stateful.snippet")}
  title="Stateful Component"
  theme={nightOwl}
  showNumbers
  steps={[
    { notes: ''},
    { range: [5,11]},
    { range: [14,20]}
  ]}
/>

---

export default Invert

<PriceTicker />

---

export default Invert

## Advantages
- Easy to manage component state
## Disadvantages
- Can be more complexity than we need
- Not all components need to manage state

---

# Stateless Functional Component

---

<CodeSurfer 
  code={require("raw-loader!./snippets/sfc.snippet")}
  title="Stateless Functional Component (SFC)"
  theme={nightOwl}
/>

---

export default Invert

# Stateless Functional

## Advantages
 - simplicity
 - enforces pure function practices
 - easy to test
 - eliminates ES6 class related boilerplate (constructor(), extends, etc)
 - no 'this' keyword

## Disadvantages
  - design inconsistencies
  - conversion hassle
  - can't I just use a PureComponent?

<Notes>Inability to manage state is more of a feature and not a bug</Notes>

---

<Image src="./assets/images/sfc-stateful-babel-comparision.png" size="1100px" />

Source: [Cory House's Blog Post on SFC's](https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc)

---


# Container vs. Presentational Components

---

<CodeSurfer 
  code={require("raw-loader!./snippets/p&c.snippet")}
  title="Presentational + Container"
  theme={nightOwl}
  steps={[
    { notes: ''},
    { range: [1,7]},
    { range: [9,48]},
    { notes: ''},
  ]}
/>

---

# Stakeholder Demands

 *"We want to allow users to refresh prices whenever they'd like"*

---

# Compound Components

<Notes>
  - Inversion of control
  - Abstracts away some complexity by managing state within itself
  - Turning your components into legos
</Notes>

---

Great for handling Rendering logic

<Notes>
  - Consider for a moment some of your own code. Do you have a React component that keeps getting new rendering options?
  - Ryan Florence has a great talk on this though he doesn't use static properties
</Notes>

---

## Building a Compound Component

- static properties
- React.Children.Map
- React.cloneElement

<Notes>
  - `static`  (ES6) defines static methods on a class. Included by default in CRA
</Notes>

---

<CodeSurfer 
  code={require("raw-loader!./snippets/compound.snippet")}
  title="Implementation"
  theme={nightOwl}
  steps={[
    { notes: ''},
    { range: [5,15]},
    { range: [38,49]},
    { notes: ''},
  ]}
/>

---

<CodeSurfer 
  code={require("raw-loader!./snippets/compound-usage.snippet")}
  title="Usage"
  theme={nightOwl}
/>

---

export default Invert

<PriceTickerCompound>
  <PriceTickerCompound.Button>Update</PriceTickerCompound.Button>
  <PriceTickerCompound.Row currency="BTC" />
  <PriceTickerCompound.Row currency="ETH" />
</PriceTickerCompound>

---

export default Invert

# Compound Component

## Advantages
 - inverts rendering control to your user
 - flexible to change
 - great for code sharing and reuse

## Disadvantages
  - can't access nested children (without the Context API) 
  - can lead to bloated render() methods

<Notes>
  - Can be combined with the new React Context API to pass state to deeply nested children
</Notes>

---


# Stakeholder Demands

 *"We want dark mode"*

---
# Higher Order Component

<Notes>
  - Common in 3rd party libraries
  - Whereas a component transforms props into UI, a higher-order component transforms a component into another component.
</Notes>

---

## Higher Order Function:

*A higher order function is a function that takes a function as an argument, or returns a function.*

<Notes>
  - Allows for more declarative code
  - In contrast to first order functions, which donâ€™t take a function as an argument or return a function as output
</Notes>

---
### Higher Order Function:
Allows for more declarative code

---
### Higher Order Function:
* `Array.map()`
* `Array.filter()`
* `Array.reduce()`
---

<CodeSurfer 
  code={require("raw-loader!./snippets/hoc.snippet")}
  title="Implementation"
  theme={nightOwl}
/>

---

```jsx
import PriceTicker from "../PriceTicker"

const PriceTickerWithDarkTheme = withDarkThemeToggle(PriceTicker)

<PriceTickerWithDarkTheme />
```

---

export default Invert

<PriceTickerWithDarkTheme />

---
export default Invert

# Higher Order Component (HOC)

## Advantages
## Disadvantages
- where did this prop come from?

---

# Render Props 
## (or Render Callback)
## (or Children as a Function)

---

# Understanding JSX

---

## Remember: JSX is just a function call

---

## Remember: In JSX, curly braces indicate an argument to React.createElement()

[See Babel](https://babeljs.io/repl/#?babili=false&browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=MYewdgzgLgBAFgUwDZJDAvDAFABwE4g4QCUGAfDAN4BQMMeCUArnmDADwAmAlgG5kAJZKhgB3EHiScAhDACyATxhgAhgFsEMbhCr5CEAHSqNAX3YB6HvwDc1E9SA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=react&prettier=false&targets=&version=6.26.0&envVersion=) 

---

## We can implement an HOC with a Render Prop

---
export default Invert

# Render Props

## Advantages
- very flexible
- unopinionated
- reduce naming collisions
- dynamic composition (composing inside render())

## Disadvantages
- nesting can lead to hideous render() methods
- can be difficult to test

---

# The Future of Render Props

---

export default Invert

<img src="./assets/images/salt.svg" width="400px" height="auto"/>

---

# Thanks
