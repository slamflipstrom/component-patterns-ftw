
import { Image, Notes } from 'mdx-deck'
import { Invert } from 'mdx-deck/layouts'
import {CodeSurfer } from "mdx-deck-code-surfer"
import nightOwl from "prism-react-renderer/themes/nightOwl"

import  PriceTicker  from 'components/PriceTicker/PriceTicker'
import  PriceTickerCompound  from 'components/PriceTicker/PriceTickerCompound'
import  Tooltip  from 'components/Tooltip/Tooltip'
import  withThemeToggle  from 'components/darkThemeToggle/darkThemeToggle'

# React Component Patterns
---

# Some background

<Notes>
  Help us to combat:
  - ill-defined project requirements, constant design changes, poorly documented code
</Notes>

---
<CodeSurfer 
  code={require("raw-loader!./snippets/first.snippet")}
  theme={nightOwl}
/>
---

# React Component API
- render
- state
- props
- context
- lifecycle events

---
# Stateful Component
---
<CodeSurfer 
  code={require("raw-loader!./snippets/stateful.snippet")}
  title="Stateful Component"
  theme={nightOwl}
  steps={[
    { notes: ''},
    { range: [16,20]}
  ]}
/>

---


<PriceTicker />
<Tooltip contents="hi React Denver" id="tooltip1"/>

---

export default Invert

## Advantages
- Easy to manage component state
## Disadvantages
- Can be more complexity than we need
- Not all components need to manage state

---


# Stateless Functional Component

---

<CodeSurfer 
  code={require("raw-loader!./snippets/sfc.snippet")}
  title="Stateless Functional Component (SFC)"
  theme={nightOwl}
/>

---
export default Invert

# Stateless Functional Component

## Advantages
 - simplicity
 - enforces pure function practices
 - easy to test
 - eliminates ES6 class related boilerplate (constructor(), extends, etc)
 - no 'this' keyword

## Disadvantages
  - design inconsistencies
  - conversion hassle
  - can't I just use a PureComponent?

<Notes>Inability to manage state is more of a feature and not a bug</Notes>

---

<Image src="./assets/images/sfc-stateful-babel-comparision.png" size="1100px" />

Source: [Cory House's Blog Post on SFC's](https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc)
---


# Container vs. Presentational Components

---

<CodeSurfer 
  code={require("raw-loader!./snippets/p&c.snippet")}
  title="Presentational + Container"
  theme={nightOwl}
  showNumbers
  steps={[
    { notes: ''},
    { range: [1,7]},
    { range: [9,43]},
    { notes: ''},
  ]}
/>

---

# Stakeholder Demands

 *"We want to allow users refresh prices whenever they'd like"*

---

# Compound Components

<Notes>
  - Inversion of control
  - Abstracts away some complexity by managing state within itself
  - Turning your components into legos
</Notes>

---

Great for handling Rendering logic

<Notes>Consider for a moment some of your own code. Do you have a React component that keeps getting new rendering options?
  - Ryan Florence has a great talk on this though he doesn't use static properties
</Notes>

---

## Building a Compound Component

- static properties
- React.Children.Map
- React.cloneElement

<Notes>
  - `static`  (ES6) defines static methods on a class. Included by default in CRA
</Notes>

---

<CodeSurfer 
  code={require("raw-loader!./snippets/compound.snippet")}
  title="Implementation"
  theme={nightOwl}
/>

---

# Stuff

<CodeSurfer 
  code={require("raw-loader!./snippets/compound-usage.snippet")}
  title="not"
  theme={nightOwl}
/>

---

<PriceTickerCompound>
  <PriceTickerCompound.Button>Update</PriceTickerCompound.Button>
  <PriceTickerCompound.Row currency="BTC" />
  <PriceTickerCompound.Row currency="ETH" />
</PriceTickerCompound>

---

export default Invert

# Compound Component

## Advantages
 - inverts rendering control to your user
 - flexible to change
 - great for code sharing and reuse

## Disadvantages
  - can't access nested children (without the Context API) 
  - can lead to bloated render() methods

<Notes>
  - Can be combined with the new React Context API to pass state to deeply nested children
</Notes>
---


# Stakeholder Demands

 *"We want dark mode"*

---
# Higher Order Component

---

## Higher Order Function:
*A higher order function is a function that takes a function as an argument, or returns a function.*
<Notes>
  - Allows for more declarative code
  - In contrast to first order functions, which donâ€™t take a function as an argument or return a function as output
</Notes>

---
### Higher Order Function:
 
---
### Higher Order Function:
* `Array.map()`
* `Array.filter()`
* `Array.reduce()`

---

## Look familiar?

<CodeSurfer 
  code={'jsx connect(mapStateToProps)(PriceTicker))'}
  theme={nightOwl}
/>

---



---
export default Invert

# Higher Order Component (HOC)

## Advantages
## Disadvantages

---

# Render Props 
## (or Render Callback)
## (or Children as a Function)

---

# Understanding JSX

---

## Remember: JSX is just a function call

---

## Remember: In JSX, curly braces indicate an argument to React.createElement()

---
export default Invert

# Render Props

## Advantages
## Disadvantages

---

# The Future of Render Props

`show suspense example`

---

<img src="./assets/images/salt.svg" width="400px" height="auto"/>

---

# Thanks

---


# The end